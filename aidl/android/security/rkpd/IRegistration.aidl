/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.rkpd;

import android.security.rkpd.RemotelyProvisionedKey;

/**
 * This interface is associated with the registration of an
 * IRemotelyProvisionedComponent. Each component has a unique database of keys
 * and certificates that are provisioned to the device for attestation. An
 * IRegistration binder is created by calling {@link IRegistrar#getRegistration()}.
 *
 * This interface is used to query for available keys and certificates for the
 * registered component.
 *
 * @hide
 */
interface IRegistration {
    /**
     * Fetch a remotely provisioned key for the given keyId. Keys are unique
     * per caller/keyId/registration tuple. This ensures that no two
     * applications are able to correlate keys to uniquely identify a
     * device/user.
     *
     * If this registration is rkp only (see isRkpOnly parameter in
     * {@link IRegistrar#getRegistration()}), and no keys are immediately
     * available, then this function blocks until the remote provisioning
     * service can be contacted and either keys are provisioned or an error
     * occurs.
     *
     * If this registration is NOT rkp only, and no keys are available, this
     * function returns null.
     *
     * @param keyId This is a client-chosen key identifier, used to
     * differentiate between keys for varying client-specific use-cases. For
     * example, keystore2 passes the UID of the applications that call it as
     * the keyId value here, so that each of keystore2's clients gets a unique
     * key.
     */
    RemotelyProvisionedKey getRemotelyProvisionedKey(int keyId);

    /**
     * Key upgrade is a mechanism that prevents keys from being used on a
     * rolled-back system. In certain cases, such as an update of critical
     * device firmware (e.g. via an OTA update), the component which supports
     * operations with the remotely provisioned key blobs (e.g. KeyMint) must
     * report that a key requires upgrade. When this happens, this function must
     * be called so that the registration can upgrade the key, replacing the old
     * key blob with a new one generated by the underlying remotely provisioned
     * component.
     *
     * Note that this function does NOT extend the lifetime of key blobs. The
     * certificate for the key is unchanged, and the key will still expire at
     * the same time it would have if upgradeKey had never been called.
     *
     * @see IRemotelyProvisionedComponent#upgradeKey()
     *
     * @param keyId The identifier of the key being upgraded.
     * @param oldKeyBlob The blob contained in the RemotelyProvisionedKey that was
     * returned by getRemotelyProvisionedKey. This blob will be replaced.
     *
     * @return The new blob that replaced oldKeyBlob.
     *
     * Errors:
     * - Return STATUS_INVALID_KEY_ID if keyId is not a valid identifier.
     * - Return STATUS_BAD_KEY_BLOB if the current key blob identified by keyId is
     *   not bit-for-bit equal to oldKeyBlob.
     */
    byte[] upgradeKey(int keyId, in byte[] oldKeyBlob);
}
